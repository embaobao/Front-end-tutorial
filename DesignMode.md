# 设计模式

1. [blog 图说设计模式](https://design-patterns.readthedocs.io/zh_CN/latest/)
2. [闭包](https://www.jianshu.com/p/102e44f35b3b)
3. [MDN 闭包](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Closures)



## [工厂模式](https://baike.baidu.com/item/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/9852061)

> 工厂方法模式定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类
>
> - 简单工厂模式
> - 工厂模式
> - 抽象工厂模式

### 简单工厂模式

> 实例化对象的时候不再使用 new Object()形式，可以根据用户的选择条件来实例化相关的类。对于客户端来说，去除了具体的类的依赖。只需要给出具体实例的描述给工厂，工厂就会自动返回具体的实例对象。



这样做的优点：我们可以对创建的对象进行一些 “加工” ，而且客户端并不知道，因为工厂隐藏了这些细节。如果，没有工厂的话，那我们是不是就得自己在客户端上写这些代码，这就好比本来可以在工厂里生产的东西，拿来自己手工制作，不仅麻烦以后还不好维护。


但是缺点也很明显：如果需要在方法里写很多与对象创建有关的业务代码，而且需要的创建的对象还不少的话，我们要在这个简单工厂类里编写很多个方法，每个方法里都得写很多相应的业务代码，而每次增加子类或者删除子类对象的创建都需要打开这简单工厂类来进行修改。这会导致这个简单工厂类很庞大臃肿、耦合性高，而且增加、删除某个子类对象的创建都需要打开简单工厂类来进行修改代码也违反了开-闭原则。




### 工厂模式

> 工厂方法模式是对简单工厂模式进一步的解耦，因为在工厂方法模式中是一个子类对应一个工厂类，而这些工厂类都实现于一个抽象接口。这相当于是把原本会因为业务代码而庞大的简单工厂类，拆分成了一个个的工厂类，这样代码就不会都耦合在同一个类里了。

工厂模式中，要增加产品类时也要相应地增加工厂类，客户端的代码也增加了不少。工厂方法把简单工厂的内部逻辑判断转移到了客户端代码来进行。

你想要加功能，本来是改工厂类的，而现在是修改客户端。而且各个不同功能的实例对象的创建代码，也没有耦合在同一个工厂类里，这也是工厂方法模式对简单工厂模式解耦的一个体现。工厂方法模式克服了简单工厂会违背开-闭原则的缺点，又保持了封装对象创建过程的优点。

但工厂方法模式的缺点是每增加一个产品类，就需要增加一个对应的工厂类，增加了额外的开发量。


### 抽象工厂模式

场景：对数据库中的表进行修改

此时，使用工厂模式结构图如下：

工厂模式都可以很好的解决，由于多态的关系，sqlFactory在声明对象之前都不知道在访问哪个数据库，却可以在运行时很好的完成任务，这就是业务逻辑与数据访问的解耦。

但是，当数据库中不止一个表的时候该怎么解决问题呢，此时就可以引入**抽象工厂模式**了，结构图如下：

1. 抽象工厂模式最大的好处是易于交换产品系列，由于具体工厂类，例如 IFactory factory=new OracleFactory(); 在一个应用中只需要在初始化的时候出现一次，这就使得改变一个应用的具体工厂变得非常容易，它只需要改变具体工厂即可使用不同的产品配置。不管是任何人的设计都无法去完全防止需求的更改，或者项目的维护，那么我们的理想便是让改动变得最小、最容易，例如我现在要更改以上代码的数据库访问时，只需要更改具体的工厂即可。
2. 抽象工厂模式的另一个好处就是它让具体的创建实例过程与客户端分离，客户端是通过它们的抽象接口操作实例，产品实现类的具体类名也被具体的工厂实现类分离，不会出现在客户端代码中。就像我们上面的例子，客户端只认识IUser和ILogin，至于它是MySQl里的表还是Oracle里的表就不知道了。

缺点：

1. 如果你的需求来自增加功能，比如增加Login表，就有点太烦了。首先需要增加 ILogin，mysqlLogin,oracleLogin。 然后我们还要去修改工厂类： sqlFactory， mysqlFactory， oracleFactory 才可以实现，需要修改三个类，实在是有点麻烦。
2. 还有就是，客户端程序肯定不止一个，每次都需要声明sqlFactory factory=new MysqlFactory()， 如果有100个调用数据库的类，就需要更改100次sqlFactory factory=new oracleFactory()。

### Js [的工厂模式](https://www.cnblogs.com/minigrasshopper/p/9146417.html)

[简书工厂模式](https://www.jianshu.com/p/11918dd0f694)

- 简单工厂模式：使用一个类(通常为单体)来生成实例
- 复杂工厂模式：使用子类来决定一个变量成员应该为哪个具体的类的实例.(工厂方法模式)
- 抽象工厂模式

工厂方法模式的本意是将实际创建对象的工作推迟到子类中，这样核心类就变成了抽象类。但是在JavaScript中很难像传统面向对象那样去实现创建抽象类。所以在JavaScript中我们只需要参考它的核心思想即可。我们可以将工厂方法看作是一个实例化对象的工厂类。

在简单工厂模式中，我们每添加一个构造函数需要修改两处代码。现在我们使用工厂方法模式改造上面的代码，刚才提到，工厂方法我们只把它看作是一个实例化对象的工厂，它只做实例化对象这一件事情！ 我们采用安全模式创建对象。

#### 简单工厂模式

简单工厂的优点在于，你只需要一个正确的参数，就可以获取到你所需要的对象，而无需知道其创建的具体细节。但是在函数内包含了所有对象的创建逻辑（构造函数）和判断逻辑的代码，每增加新的构造函数还需要修改判断逻辑代码。当我们的对象不是上面的3个而是30个或更多时，这个函数会成为一个庞大的超级函数，便得难以维护。所以，简单工厂只能作用于**创建的对象数量较少，对象的创建逻辑不复杂时使用**。

```javascript
var BicycleShop = function () { };
BicycleShop.prototype = {
  sellBicycle: function (model) {
    var bicycle;
    switch (model) {
      case "A"://A类型的自行车  
        bicycle = new A();
        break;
      case "B":
        bicycle = new B();
        break;
      case "C":
        bicycle = new C();
        break;
    }
    return bicycle;
  }
}
```

#### 工厂模式

我们打算让各个自行车商店自行决定从哪个生产厂家进货。鉴于此，单靠一个自行车工厂（BicycleFactory）是无法提供需要的所有的自行车的。 所以我们考虑将BicycleShop设计为一个抽象类，让子类根据各自的进货渠道实现其进货自行车（createBicycle）的工作：

```javascript
var BicycleShop = function(){};
BicycleShop.prototype = {
    sellBicycle : function(model){
        //让其子类来完成这个工作
        var bicycle = this.createBicycle(model);
        return bicycle;
    },
    //抽象方法，必须实现后才能调用
    createBicycle : function(model){
        throw new Error("必须通过子类的实例才能调用此方法，进货自行车");
    }
};
```

#### 抽象工厂模式

简单工厂模式和工厂方法模式都是直接生成实例，但是抽象工厂模式不同，抽象工厂模式并不直接生成实例， 而是用于对产品类簇的创建。

```javascript
let WechatUser = function() {}
WechatUser.prototype = {
  getName: function() {
    return new Error('抽象方法不能调用');
  }
}
```

如果子类继承 但是并没有去重写`getName`，那么子类的实例化对象就会调用父类的`getName`方法并抛出错误提示。

## 单例模式

单例模式很常用，比如全局缓存、全局状态管理等等这些只需要一个对象，就可以使用单例模式。

单例模式的核心就是保证全局只有一个对象可以访问。因为 JS 是门无类的语言，所以别的语言实现单例的方式并不能套入 JS 中，我们只需要用一个变量确保实例只创建一次就行